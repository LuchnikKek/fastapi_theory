# Pet-проект FastAPI
Часть кода будет взята из курса от Яндекса. 
Часть задачек выдумаю сам.

_Just playground._

## Список реализованного
- Контроль закрытия соединения с базой через lifespan
- Провайдер `FilmService`, получающий модель бизнес-логики `Film`.
- Кэширование ответа в Redis.
- API-ручка, преобразующая модель `Film` бизнес-логики в API-модель `Film`.
- Dependency Injection между вложенными объектами: **ручкой film_details | провайдером FilmService | Elastic, Redis**.
- Самогенерирующаяся Swagger-документация по endpoint'у `/api/openapi`, а json по `/api/openapi.json`.
---

## API
Подробную документацию можно найти на `/api/openapi`.

#### Get film by id

```http
  GET /api/v1/films/{id}
```

| Parameter | Type     | Description                       |
|:----------| :------- |:----------------------------------|
| `id`      | `str` | **Required**. ID of film to fetch |

**Returns:**

```json
{"id": "str_id", "title":  "str_title"}
```
---

## Немного о работе API
При вызове ручка дёргает у своего Service (Провайдера) метод `get_by_id`. Метод в свою очередь возвращает `Film`. 
Вся бизнес-логика обращений к базе, парсинга моделей, кэширования, обработки ошибок находится в `Service` классе.
Он возвращает либо `Film`, либо `None`. 
Получив ответ, ручка сама решает, как его распарсить и какую ошибку выбросить в случае `None`.

Ручка использует Service, Service использует соединения с ES и Redis. DI удаётся добиться благодаря `fastapi.Depends`.
Это класс, просто принимающий функцию. И возвращающий обратно её результат. 
Идея в том, что указывая его в сигнатуре класса, мы можем имплементировать эту функцию как угодно.
Можем возвращать классы и соединения по любой кастомной логике, не затрагивая при этом сами классы.
